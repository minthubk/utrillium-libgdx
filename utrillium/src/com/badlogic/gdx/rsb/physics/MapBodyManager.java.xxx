package com.badlogic.gdx.rsb.physics;

import java.util.Iterator;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.tiled.TiledLayer;
import com.badlogic.gdx.graphics.g2d.tiled.TiledMap;
import com.badlogic.gdx.math.Circle;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.ChainShape;
import com.badlogic.gdx.physics.box2d.CircleShape;
import com.badlogic.gdx.physics.box2d.FixtureDef;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.Shape;
import com.badlogic.gdx.physics.box2d.World;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Logger;
import com.badlogic.gdx.utils.XmlReader;
import com.badlogic.gdx.utils.XmlReader.Element;

/**
 * @author Rob Baines 
 * Based upon - David Saltares Mรกrquez MapBodyManger
 * 
 * @brief Populates box2D world with static bodies using data from a map object
 * 
 *
 */
public class MapBodyManager {
	private Logger m_logger;
	private World m_world;
	private float m_units;
	private Array<Body> m_bodies = new Array<Body>();
	
	/**
	 * @param world box2D world to work with.
	 * @param unitsPerPixel conversion ratio from pixel units to box2D metres.
	 * @param materialsFile xml file with specific physics properties to be assigned to newly created bodies.
	 * @param loggingLevel verbosity of the embedded logger.
	 */
	public MapBodyManager(World world, float unitsPerPixel, int loggingLevel) {
		m_logger = new Logger("MapBodyManager", loggingLevel);
		m_logger.info("initialising");
		
		m_world = world;
		m_units = unitsPerPixel;
		
		
	}
	
	/**
	 * @param map will use the "physics" layer of this map to look for shapes in order to create the static bodies.
	 */
	public void createPhysics(TiledMap map) {
		createPhysics(map,0);
	}
	
	/**
	 * @param map map to be used to create the static bodies. 
	 * @param layerName name of the layer that contains the shapes.
	 */
	public void createPhysics(TiledMap map, int layerIndex) {
		TiledLayer layer = map.layers.get(layerIndex);
		
		if (layer == null) {
			m_logger.error("layer index:" + layerIndex + " does not exist");
			return;
		}
		
		int[][] tiles = layer.tiles;
		
		// iterate through all tiles in layer		
		FixtureDef defaultFixture = new FixtureDef();
		defaultFixture.density = 1.0f;
		defaultFixture.friction = 0.8f;
		defaultFixture.restitution = 0.0f;
		
		for(int row=0;row<map.width;row++) {
			for(int col=0;col<map.height;col++) {
				// create physics body for non-empty tiles
				int tileId = tiles[row][col];
				Shape shape;
				
				if(tileId!= 0) {
					// 
					m_logger.info("Solid tile at:" +row+","+col);
					shape = getRectangle(row,col);
					
					/*MapProperties properties = object.getProperties();
					String material = properties.getAsString("material", "default");
					FixtureDef fixtureDef = m_materials.get(material);
					
					if (fixtureDef == null) {
						m_logger.error("material does not exist " + material + " using default");
						fixtureDef = m_materials.get("default");
					}
					*/
					// use default fixture for now
					FixtureDef fixtureDef = defaultFixture;
					
					fixtureDef.shape = shape;
					
					BodyDef bodyDef = new BodyDef();
					bodyDef.type = BodyDef.BodyType.StaticBody;
					
					Body body = m_world.createBody(bodyDef);
					body.createFixture(fixtureDef);
					
					m_bodies.add(body);
					
					fixtureDef.shape = null;
					shape.dispose();
				}
			}
		}
		
	}
	
	/**
	 * Destroys every static body that has been created using the manager.
	 */
	public void destroyPhysics() {
		for (Body body : m_bodies) {
			m_world.destroyBody(body);
		}
		
		m_bodies.clear();
	}
	
	
	private Shape getRectangle(int row, int col) {
		PolygonShape polygon = new PolygonShape();
		Vector2 size = new Vector2( m_units, m_units);
		polygon.setAsBox(row * m_units,
						 col * m_units,
						 size,
						 0.0f);
		return polygon;
	}
	/*
	private Shape getCircle(CircleMapObject circleObject) {
		Circle circle = circleObject.getCircle();
		CircleShape circleShape = new CircleShape();
		circleShape.setRadius(circle.radius * m_units);
		circleShape.setPosition(new Vector2(circle.x * m_units, circle.y * m_units));
		return circleShape;
	}
	
	private Shape getPolygon(PolygonMapObject polygonObject) {
		PolygonShape polygon = new PolygonShape();
		float[] vertices = polygonObject.getPolygon().getVertices();
		float[] worldVertices = new float[vertices.length];
		
		for (int i = 0; i < vertices.length; ++i) { 
			worldVertices[i] = vertices[i] * m_units;
		}
		
		polygon.set(worldVertices);
		return polygon;
	}
	
	private Shape getPolyline(PolylineMapObject polylineObject) {
		float[] vertices = polylineObject.getPolygon().getVertices();
		Vector2[] worldVertices = new Vector2[vertices.length / 2];
		
		for (int i = 0; i < vertices.length / 2; ++i) {
			worldVertices[i] = new Vector2();
			worldVertices[i].x = vertices[i * 2] * m_units;
			worldVertices[i].y = vertices[i * 2 + 1] * m_units;
		}
		
		ChainShape chain = new ChainShape(); 
		chain.createChain(worldVertices);
		return chain;
	}
	*/
}